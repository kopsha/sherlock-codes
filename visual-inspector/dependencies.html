{% extends 'base.html' %}

{% block title %}
    Sherlock Reports - Dependencies
{% endblock %}

{% block scripts %}
    <script>
    function update_info_view(d) {
        info_text = "<p>"
        info_text += d.data.name + "<hr>";

        if (d.children) {
            info_text += "source files: <b>" + d.data.counter.source_files + "</b><br>";
            info_text += "lines of code: <b>" + d.data.counter.sloc_count + "</b><br>";
            info_text += "risk messages: <b>" + d.data.counter.risks_count + "</b><br>";
            info_text += "aggregated complexity: <b>" + d.data.counter.value_count + "</b><br>";
        } else {
            info_text += "file type: <b>" + d.data.meta.type + "</b><br>";
            info_text += "lines of code: <b>" + d.data.meta.sloc + "</b><br>";
            info_text += "decision complexity: <b>" + d.data.meta.decision_complexity + "</b><br>";
            info_text += "nested complexity: <b>" + d.data.meta.nested_complexity + "</b><br>";
            if (d.data.meta.imports) {
                info_text += "imports:<br>"
                d.data.meta.imports.local.forEach( function (el) {
                    info_text += el + "<br>";
                });
            }
            info_text += "risks:<br>";
            d.data.meta.risks.forEach( function (el) {
                info_text += el + "<br>";
            });
        }
        info_text += "</p>"
        info_view.html( info_text );
    }


    function create_svg_element(s) {
        let div= document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
        div.innerHTML= '<svg xmlns="http://www.w3.org/2000/svg">'+s+'</svg>';
        let frag= document.createDocumentFragment();
        while (div.firstChild.firstChild)
            frag.appendChild(div.firstChild.firstChild);
        return frag;
    }

    function autoBox() {
        const {x, y, width, height} = this.getBBox();
        return [x, y, width, height];
    }    

    function render_svg(url) {
        let svg_tag = create_svg_element('<svg width="768" height="768">');
        graphic_view.empty();
        graphic_view.append(svg_tag);
        let svg = d3.select("svg").style("box-sizing", "border-box"),
            margin = 20,
            diameter = svg.attr("width"),
            g = svg.append("g").attr(
                "transform",
                "translate(" + diameter / 2 + "," + diameter / 2 + ")"
            );

        //g.attr("viewBox", autoBox);

        let color = d3.scaleLinear()
            .domain([-1, 13])
            .range(["hsl(150,80%,80%)", "hsl(300,52%,38%)"])
            .interpolate(d3.interpolateHcl);

        let cluster = d3.cluster()
            .size([2 * Math.PI, diameter/4])

        d3.json(url).then( function (data) {
            // Give the data to this cluster layout:
            const root = cluster(d3.hierarchy(data));

const link = g.append("g")
  .attr("fill", "none")
  .attr("stroke", "#555")
  .attr("stroke-opacity", 0.4)
  .attr("stroke-width", 1.5)
.selectAll("path")
.data(root.links())
.enter().append("path")
  .attr("d", d3.linkRadial()
      .angle(d => d.x)
      .radius(d => d.y));

const node = g.append("g")
  .attr("stroke-linejoin", "round")
  .attr("stroke-width", 3)
.selectAll("g")
.data(root.descendants().reverse())
.enter().append("g")
  .attr("transform", d => `
    rotate(${d.x * 180 / Math.PI - 90})
    translate(${d.y},0)
  `);

node.append("circle")
  .attr("fill", d => d.children ? "#555" : "#999")
  .attr("r", d => d.data.value/10 + 2);

node.append("text")
    .attr("class", "label")
  .attr("dy", "0.31em")
  .attr("x", d => d.x < Math.PI === !d.children ? 6 : -6)
  .attr("text-anchor", d => d.x < Math.PI === !d.children ? "start" : 
"end")
  .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
  .text(d => d.data.name)
  .filter(d => d.children)
  .clone(true).lower()
  .attr("stroke", "white");
            svg.attr("viewBox", autoBox);
            update_info_view(root);
        });
    }

    </script>
{% endblock %}
